在React里,对于数据的管理,除了`props`和`state`,还有一个`content`的API,它提供了跨组件的通信能力.这在一些小的项目里面,它也可以充当一个`redux`的角色.

React提供了一个`createContext`的方法,它接受一个默认值的入参,返回一个`Provider`和`Consumer`的组件,`Provider`组件接受一个`value`的`props`属性,同时在`Consumer`组件的`children`为一个函数,它的入参便是该`value`值.

基于此,在`src/react/index.js`里面实现这个`createContext`方法.

```diff
+function createContext(value){
+    let context = {
+        _value: value,
+        Provider,
+        Consumer,
+    };
+    function Provider({value, children}){ // Provider接收一个value的props
+        context._value = value;
+        return children;
+    }
+    function Consumer({children}){ // Consumer的children是一个函数
+        return children(context._value)
+    }
+    return context;
+}

const React = {
    createElement,
    Component,
    createRef,
+    createContext,
    forwardRef,
}
```

在类组件中,我们一般是通过声明一个静态属性`contextType`来使用,当声明了该属性之后,该类的实例上面就会挂载一个`context`的属性,其值便是`Provider`的上面的`value`值.

修改`src/react-dom/index.js`里面的`mountClassComponent`方法,如果类组件上面存在该静态方法,便将`value`值挂载到`context`上面.

```diff
function mountClassComponent(vdom) {
    const {type, props, ref} = vdom;
    const defaultProps = type.defaultProps || {};
    const combinedProps = {...defaultProps, ...props};
    const classInstance = new type(combinedProps);
+    if(type.contextType){
+        classInstance.context = type.contextType._value;
+    }
    if(classInstance.componentWillMount) classInstance.componentWillMount();
    if(type.getDerivedStateFromProps){
        classInstance.state = type.getDerivedStateFromProps(combinedProps, classInstance.state) || classInstance.state;
    }
    const classInstanceVdom = wrapToVdom(classInstance.render());
    classInstance.oldVdom =  classInstanceVdom; // 将虚拟dom挂载到当前组件实例上面.接下来的真实dom会挂到classInstanceVdom和classInstance.oldVdom上面;
    vdom.classInstance = classInstance;
    if (ref) {
        ref.current = classInstance;
    }
    const dom = createDom(classInstanceVdom);
    if(classInstance.componentDidMount) dom.componentDidMount = classInstance.componentDidMount.bind(classInstance);
    return dom;
}
```

同时修改`src/react/Component.js`里面的`forceUpdate`方法,因为在更新阶段,也要考虑`Provider`上面的`value`有更新了,所以同时也需要更新组件实例上面的`context`值.

```diff

    forceUpdate(triggerFromUpdate = false, prevProps, prevState) {
        const oldVdom = this.oldVdom;
        if(!triggerFromUpdate && this.constructor.getDerivedStateFromProps){
            this.state = this.constructor.getDerivedStateFromProps(this.props, this.state) || this.state;
        }
+       if(this.constructor.contextType){
+            this.context = this.constructor.contextType._value;
+        }
        const newVdom = this.render();
        let extraArgs;
        if(this.getSnapshotBeforeUpdate){
            extraArgs = this.getSnapshotBeforeUpdate();
        }
        compareTwoVdoms(oldVdom, newVdom)
        this.oldVdom = newVdom; // 将更新后的虚拟DOM更新到原来的oldVdom上面
        if(this.componentDidUpdate){
            if(triggerFromUpdate){
                this.componentDidUpdate(prevState, prevState, extraArgs);
            }else{
                this.componentDidUpdate(this.props, this.state, extraArgs);
            }
        }
    }
```

新建`src/components/CreateContext.js`文件,写一个通过`context`传递数据和方法的组件,包括类组件和函数组件里面的使用.

```js
import React from '../react';

const ThemeContext = React.createContext();

class Parent extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            color: 'gray',
        }
    }

    changeColor = (color) => {
        this.setState({color})
    }

    render() {
        const value = {color: this.state.color, changeColor: this.changeColor}
        return <ThemeContext.Provider value={value}>
            <Child/>
        </ThemeContext.Provider>
    }
}

class Child extends React.Component {
    static contextType = ThemeContext;

    render() {
        return <div>{this.context.color}
            <ChangeButton/>
        </div>
    }
}

function ChangeButton() {
    return <ThemeContext.Consumer>
        {value => <button onClick={() => value.changeColor('red')}>change</button>}
    </ThemeContext.Consumer>
}

export default Parent;
```

可以看到,父组件上面的`color`属性和`changeColor`方法,都可以在子组件,子子组件中通过`context`来获取到,而无须通过`props`的层层传递.